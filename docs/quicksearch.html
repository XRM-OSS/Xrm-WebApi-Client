<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"WebApiClient.Core.js.html":{"id":"WebApiClient.Core.js.html","title":"Source: WebApiClient.Core.js","body":" Xrm-WebApi-Client Modules WebApiClient Source: WebApiClient.Core.js /* @preserve * MIT License * * Copyright (c) 2016 Florian Krönert * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the &quot;Software&quot;), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. * */ /** @preserve * WebApiClient build version v0.0.0 */ /** * This is the core functionality of Xrm-WebApi-Client * No instantiation needed, it's a singleton. * @module WebApiClient */ (function (undefined) { &quot;use strict&quot;; var WebApiClient = {}; var batchName = &quot;batch_UrlLimitExeedingRequest&quot;; /** * @description The API version that will be used when sending requests. Default is &quot;8.0&quot; * @param {String} * @memberof module:WebApiClient */ WebApiClient.ApiVersion = &quot;8.0&quot;; /** * @description Checks for more pages when retrieving results. If set to true, all pages will be retrieved, if set to false, only the first page will be retrieved. * @param {boolean} * @memberof module:WebApiClient */ WebApiClient.ReturnAllPages = false; /** * @description Set to true for retrieving formatted error in style 'xhr.statusText: xhr.error.Message'. If set to false, error json will be returned. * @param {boolean} * @memberof module:WebApiClient */ WebApiClient.PrettifyErrors = true; /** * @description Set to false for sending all requests synchronously. True by default. * @param {boolean} * @memberof module:WebApiClient */ WebApiClient.Async = true; /** * @description Connection to use when being used in a single page app. * @param {String} * @memberof module:WebApiClient */ WebApiClient.ClientUrl = null; /** * @description Token to use for authenticating when being used in a single page app. * @param {String} * @memberof module:WebApiClient */ WebApiClient.Token = null; // This is for ensuring that we use bluebird internally, so that calls to WebApiClient have no differing set of // functions that can be applied to the Promise. For example Promise.finally would not be available without Bluebird. var Promise = require(&quot;bluebird&quot;).noConflict(); function GetCrmContext() { if (typeof (GetGlobalContext) !== &quot;undefined&quot;) { return GetGlobalContext(); } if (typeof (Xrm) !== &quot;undefined&quot;){ return Xrm.Page.context; } } function GetClientUrl () { var context = GetCrmContext(); if(context) { return context.getClientUrl(); } if (WebApiClient.ClientUrl) { return WebApiClient.ClientUrl; } throw new Error(&quot;Failed to retrieve client url, is ClientGlobalContext.aspx available?&quot;); } function MergeResults (firstResponse, secondResponse) { if (!firstResponse &amp;&amp; !secondResponse) { return null; } if (firstResponse &amp;&amp; !secondResponse) { return firstResponse; } if (!firstResponse &amp;&amp; secondResponse) { return secondResponse; } firstResponse.value = firstResponse.value.concat(secondResponse.value); delete firstResponse[&quot;@odata.nextLink&quot;]; delete firstResponse[&quot;@Microsoft.Dynamics.CRM.fetchxmlpagingcookie&quot;]; return firstResponse; } function RemoveIdBrackets (id) { if (!id) { return id; } return id.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;); } /** * @description Builds the set name of a given entity name. * @method GetSetName * @param {String} entityName Logical name of the entity, such as &quot;account&quot; * @param {String}[overriddenSetName] Override set name if it can't be infered from plural rules * @memberof module:WebApiClient * @return {String} */ WebApiClient.GetSetName = function (entityName, overriddenSetName) { if (overriddenSetName) { return overriddenSetName; } var ending = entityName.slice(-1); switch(ending) { case 's': return entityName + &quot;es&quot;; case 'y': return entityName.substring(0, entityName.length - 1) + &quot;ies&quot;; default: return entityName + &quot;s&quot;; } }; var DefaultHeaders = [ { key: &quot;Accept&quot;, value: &quot;application/json&quot; }, { key: &quot;OData-Version&quot;, value: &quot;4.0&quot; }, { key: &quot;OData-MaxVersion&quot;, value: &quot;4.0&quot; }, // Prevent caching since it sometimes sends old data as unmodified { key: &quot;If-None-Match&quot;, value: null }, { key: &quot;Content-Type&quot;, value: &quot;application/json; charset=utf-8&quot; } ]; /** * @description Returns array of default headers. * @method GetDefaultHeaders * @return {Array&lt;{key: String, value:String}&gt;} * @memberof module:WebApiClient */ WebApiClient.GetDefaultHeaders = function() { return DefaultHeaders; }; function VerifyHeader(header) { if (!header.key || typeof(header.value) === &quot;undefined&quot;) { throw new Error(&quot;Each request header needs a key and a value!&quot;); } } /** * @description Function for building the set name of a given entity name. * @method AppendToDefaultHeaders * @param {...{key:String, value:String}} var_args Headers as variable arguments * @memberof module:WebApiClient * @return {void} */ WebApiClient.AppendToDefaultHeaders = function () { if (!arguments.length) { return; } for(var i = 0; i &lt; arguments.length; i++) { var argument = arguments[i]; VerifyHeader(argument); DefaultHeaders.push(argument); } }; function AppendHeaders(xhr, headers) { if (headers) { for (var i = 0; i &lt; headers.length; i++) { var header = headers[i]; VerifyHeader(header); xhr.setRequestHeader(header.key, header.value); } } } function GetRecordUrl (parameters) { var params = parameters || {}; if ((!params.entityName &amp;&amp; !params.overriddenSetName) || (!params.entityId &amp;&amp; !params.alternateKey)) { throw new Error(&quot;Need entity name or overridden set name and entity id or alternate key for getting record url!&quot;); } var url = WebApiClient.GetApiUrl() + WebApiClient.GetSetName(params.entityName, params.overriddenSetName); if (params.alternateKey) { url += BuildAlternateKeyUrl(params); } else { url += &quot;(&quot; + RemoveIdBrackets(params.entityId) + &quot;)&quot;; } return url; } function FormatError (xhr) { if (xhr &amp;&amp; xhr.response) { var json = JSON.parse(xhr.response); if (!WebApiClient.PrettifyErrors) { json.xhrStatusText = xhr.statusText; return JSON.stringify(json); } else { var error = &quot;&quot;; if (json.error) { error = json.error.message; } return xhr.statusText + &quot;: &quot; + error; } } return &quot;&quot;; } function GetNextLink (response) { return response[&quot;@odata.nextLink&quot;]; } function GetPagingCookie(response) { return response[&quot;@Microsoft.Dynamics.CRM.fetchxmlpagingcookie&quot;]; } function SetCookie (pagingCookie, parameters) { var unescapedCookie = unescape(pagingCookie); // Parse cookie that we retrieved with response var parser = new DOMParser(); var cookieXml = parser.parseFromString(unescapedCookie, &quot;text/xml&quot;); var cookie = cookieXml.documentElement; var cookieValue = unescape(cookie.getAttribute(&quot;pagingcookie&quot;)); var pageNumber = parseInt(/&lt;cookie page=&quot;([\\d]+)&quot;&gt;/.exec(cookieValue)[1]) + 1; // Parse our original fetch XML, we will inject the paging information in here var fetchXml = parser.parseFromString(parameters.fetchXml, &quot;text/xml&quot;); var fetch = fetchXml.documentElement; fetch.setAttribute(&quot;page&quot;, pageNumber); fetch.setAttribute(&quot;paging-cookie&quot;, cookieValue); // Serialize modified fetch with paging information var serializer = new XMLSerializer(); return serializer.serializeToString(fetchXml); } function SetPreviousResponse (parameters, response) { // Set previous response parameters._previousResponse = response; } function MergeHeaders() { var headers = []; if (!arguments) { return headers; } for(var i = 0; i &lt; arguments.length; i++) { var headersToAdd = arguments[i]; if (!headersToAdd || !Array.isArray(headersToAdd)) { continue; } for (var j = 0; j &lt; headersToAdd.length; j++) { var header = headersToAdd[j]; VerifyHeader(header); var addHeader = true; for (var k = 0; k &lt; headers.length; k++) { if (headers[k].key === header.key) { addHeader = false; break; } } if (addHeader) { headers.push(header); } } } return headers; } function IsBatch(responseText) { return responseText &amp;&amp; /^--batchresponse_[a-fA-F0-9\\-]+$/m.test(responseText); } function ParseResponse(xhr) { var responseText = xhr.responseText; // Check if it is a batch response if (IsBatch(responseText)) { return new WebApiClient.BatchResponse({ xhr: xhr }); } else { return JSON.parse(xhr.responseText); } } function IsOverlengthGet (method, url) { return method &amp;&amp; method.toLowerCase() === &quot;get&quot; &amp;&amp; url &amp;&amp; url.length &gt; 2048; } function SendAsync(method, url, payload, parameters) { var xhr = new XMLHttpRequest(); var promise = new Promise(function(resolve, reject) { xhr.onload = function() { if(xhr.readyState !== 4) { return; } if(xhr.status === 200){ var response = ParseResponse(xhr); if (response instanceof WebApiClient.BatchResponse) { // If it was an overlength fetchXml, that was sent as batch automatically, we don't want it to behave as a batch if (parameters.isOverLengthGet) { response = response.batchResponses[0].payload; } // If we received multiple responses, but not from overlength get, it was a custom batch. Just resolve all matches else { resolve(response); } } var nextLink = GetNextLink(response); var pagingCookie = GetPagingCookie(response); response = MergeResults(parameters._previousResponse, response); // Results are paged, we don't have all results at this point if (nextLink &amp;&amp; (WebApiClient.ReturnAllPages || parameters.returnAllPages)) { SetPreviousResponse(parameters, response); resolve(SendAsync(&quot;GET&quot;, nextLink, null, parameters)); } else if (pagingCookie &amp;&amp; (WebApiClient.ReturnAllPages || parameters.returnAllPages)) { var nextPageFetch = SetCookie(pagingCookie, parameters); SetPreviousResponse(parameters, response); parameters.fetchXml = nextPageFetch; resolve(WebApiClient.Retrieve(parameters)); } else { resolve(response); } } else if (xhr.status === 201) { resolve(ParseResponse(xhr)); } else if (xhr.status === 204) { if (method.toLowerCase() === &quot;post&quot;) { resolve(xhr.getResponseHeader(&quot;OData-EntityId&quot;)); } // No content returned for delete, update, ... else { resolve(xhr.statusText); } } else { reject(new Error(FormatError(xhr))); } }; xhr.onerror = function() { reject(new Error(FormatError(xhr))); }; }); var headers = []; if (IsOverlengthGet(method, url)) { var batch = new WebApiClient.Batch({ requests: [new WebApiClient.BatchRequest({ method: method, url: url, payload: payload, headers: parameters.headers })], async: true, isOverLengthGet: true }); return WebApiClient.SendBatch(batch); } xhr.open(method, url, true); headers = MergeHeaders(headers, parameters.headers, DefaultHeaders); AppendHeaders(xhr, headers); // Bugfix for IE. If payload is undefined, IE would send &quot;undefined&quot; as request body if (payload) { // For batch requests, we just want to send a string body if (typeof(payload) === &quot;string&quot;) { xhr.send(payload); } else { xhr.send(JSON.stringify(payload)); } } else { xhr.send(); } return promise; } function SendSync(method, url, payload, parameters) { var xhr = new XMLHttpRequest(); var response; xhr.onload = function() { if(xhr.readyState !== 4) { return; } if(xhr.status === 200){ response = ParseResponse(xhr); // If we received multiple responses, it was a custom batch. Just resolve all matches if (response instanceof WebApiClient.BatchResponse) { // If it was an overlength fetchXml, that was sent as batch automatically, we don't want it to behave as a batch if (parameters.isOverLengthGet) { response = response.batchResponses[0].payload; } else { return; } } var nextLink = GetNextLink(response); var pagingCookie = GetPagingCookie(response); response = MergeResults(parameters._previousResponse, response); // Results are paged, we don't have all results at this point if (nextLink &amp;&amp; (WebApiClient.ReturnAllPages || parameters.returnAllPages)) { SetPreviousResponse(parameters, response); SendSync(&quot;GET&quot;, nextLink, null, parameters); } else if (pagingCookie &amp;&amp; (WebApiClient.ReturnAllPages || parameters.returnAllPages)) { var nextPageFetch = SetCookie(pagingCookie, parameters); SetPreviousResponse(parameters, response); parameters.fetchXml = nextPageFetch; WebApiClient.Retrieve(parameters); } } else if (xhr.status === 201) { response = ParseResponse(xhr); } else if (xhr.status === 204) { if (method.toLowerCase() === &quot;post&quot;) { response = xhr.getResponseHeader(&quot;OData-EntityId&quot;); } // No content returned for delete, update, ... else { response = xhr.statusText; } } else { throw new Error(FormatError(xhr)); } }; xhr.onerror = function() { throw new Error(FormatError(xhr)); }; var headers = []; if (IsOverlengthGet(method, url)) { var batch = new WebApiClient.Batch({ requests: [new WebApiClient.BatchRequest({ method: method, url: url, payload: payload, headers: parameters.headers })], async: false, isOverLengthGet: true }); return WebApiClient.SendBatch(batch); } xhr.open(method, url, false); headers = MergeHeaders(headers, parameters.headers, DefaultHeaders); AppendHeaders(xhr, headers); // Bugfix for IE. If payload is undefined, IE would send &quot;undefined&quot; as request body if (payload) { // For batch requests, we just want to send a string body if (typeof(payload) === &quot;string&quot;) { xhr.send(payload); } else { xhr.send(JSON.stringify(payload)); } } else { xhr.send(); } return response; } function GetAsync (parameters) { if (typeof(parameters.async) !== &quot;undefined&quot;) { return parameters.async; } return WebApiClient.Async; } function BuildAlternateKeyUrl (params) { if (!params || !params.alternateKey) { return &quot;&quot;; } var url = &quot;(&quot;; for (var i = 0; i &lt; params.alternateKey.length; i++) { var key = params.alternateKey[i]; url += key.property + &quot;='&quot; + key.value + &quot;'&quot;; if (i + 1 === params.alternateKey.length) { url += &quot;)&quot;; } else { url += &quot;,&quot;; } } return url; } /** * @description Sends request using given parameters. * @method SendRequest * @param {String} method Method type of request to send, such as &quot;GET&quot; * @param {String} url Target URL for request. * @param {Object} [payload] Payload for request. * @param {Object} [parameters] - Parameters for sending the request * @param {Boolean} [parameters.async] - True for sending async, false for sync. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] - Headers for appending to request * @memberof module:WebApiClient * @return {Promise&lt;Object&gt;|Object} */ WebApiClient.SendRequest = function (method, url, payload, parameters) { var params = parameters || {}; // Fallback for request headers array as fourth parameter if (Array.isArray(params)) { params = { headers: params }; } if (WebApiClient.Token) { params.headers = params.headers || []; params.headers.push({key: &quot;Authorization&quot;, value: &quot;Bearer &quot; + WebApiClient.Token}); } if (params.asBatch) { return new WebApiClient.BatchRequest({ method: method, url: url, payload: payload, headers: params.headers }); } var asynchronous = GetAsync(params); if (asynchronous) { return SendAsync(method, url, payload, params); } else { return SendSync(method, url, payload, params); } }; /** * @description Applies configuration to WebApiClient. * @method Configure * @param {Object} configuration Object with keys named after WebApiClient Members, such as &quot;Token&quot;s * @memberof module:WebApiClient * @return {void} */ WebApiClient.Configure = function (configuration) { for (var property in configuration) { if (!configuration.hasOwnProperty(property)) { continue; } WebApiClient[property] = configuration[property]; } }; /** * @description Gets the current base API url that is used. * @method GetApiUrl * @memberof module:WebApiClient * @return {String} */ WebApiClient.GetApiUrl = function() { return GetClientUrl() + &quot;/api/data/v&quot; + WebApiClient.ApiVersion + &quot;/&quot;; }; /** * @description Creates a given record in CRM. * @method Create * @param {Object} parameters Parameters for creating record * @param {String} parameters.entityName Entity name of record that should be created * @param {String} [parameters.overriddenSetName] Plural name of entity, if not according to plural rules * @param {Object} parameters.entity Object containing record data * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;String&gt;|Promise&lt;object&gt;|String|Object} - Returns Promise&lt;Object&gt; if return=representation header is set, otherwise Promise&lt;String&gt;. Just Object or String if sent synchronously. */ WebApiClient.Create = function(parameters) { var params = parameters || {}; if ((!params.entityName &amp;&amp; !params.overriddenSetName) || !params.entity) { throw new Error(&quot;Entity name and entity object have to be passed!&quot;); } var url = WebApiClient.GetApiUrl() + WebApiClient.GetSetName(params.entityName, params.overriddenSetName); return WebApiClient.SendRequest(&quot;POST&quot;, url, params.entity, params); }; /** * @description Retrieves records from CRM * @method Retrieve * @param {Object} parameters Parameters for retrieving records * @param {String} parameters.entityName Entity name of records that should be retrieved * @param {String} [parameters.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} [parameters.queryParams] Query Parameters to append to URL, such as ?$select=* * @param {String} [parameters.fetchXml] Fetch XML query * @param {String} [parameters.entityId] ID of entity to retrieve, will return single record * @param {Array&lt;property:string,value:string&gt;} [parameters.alternateKey] Alternate key array for retrieving single record * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;object&gt;|Object} - Returns Promise&lt;Object&gt; if asyncj, just Object if sent synchronously. */ WebApiClient.Retrieve = function(parameters) { var params = parameters || {}; if (!params.entityName &amp;&amp; !params.overriddenSetName) { throw new Error(&quot;Entity name has to be passed!&quot;); } var url = WebApiClient.GetApiUrl() + WebApiClient.GetSetName(params.entityName, params.overriddenSetName); if (params.entityId) { url += &quot;(&quot; + RemoveIdBrackets(params.entityId) + &quot;)&quot;; } else if (params.fetchXml) { url += &quot;?fetchXml=&quot; + escape(params.fetchXml); } else if (params.alternateKey) { url += BuildAlternateKeyUrl(params); } if (params.queryParams) { url += params.queryParams; } return WebApiClient.SendRequest(&quot;GET&quot;, url, null, params); }; /** * @description Updates a given record in CRM. * @method Update * @param {Object} parameters Parameters for updating record * @param {String} parameters.entityName Entity name of records that should be updated * @param {String} [parameters.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} [parameters.entityId] ID of entity to update * @param {Array&lt;property:string,value:string&gt;} [parameters.alternateKey] Alternate key array for updating record * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;String&gt;|Promise&lt;object&gt;|String|Object} - Returns Promise&lt;Object&gt; if return=representation header is set, otherwise Promise&lt;String&gt;. Just Object or String if sent synchronously. */ WebApiClient.Update = function(parameters) { var params = parameters || {}; if (!params.entity) { throw new Error(&quot;Update object has to be passed!&quot;); } var url = GetRecordUrl(params); return WebApiClient.SendRequest(&quot;PATCH&quot;, url, params.entity, params); }; /** * @description Deletes a given record in CRM. * @method Delete * @param {Object} parameters Parameters for deleting record * @param {String} parameters.entityName Entity name of records that should be deleted * @param {String} [parameters.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} [parameters.entityId] ID of entity to delete * @param {Array&lt;property:string,value:string&gt;} [parameters.alternateKey] Alternate key array for deleting record * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;String&gt;|String} - Returns Promise&lt;String&gt; if async, just String if sent synchronously. */ WebApiClient.Delete = function(parameters) { var params = parameters || {}; var url = GetRecordUrl(params); if (params.queryParams) { url += params.queryParams; } return WebApiClient.SendRequest(&quot;DELETE&quot;, url, null, params); }; /** * @description Associates given records in CRM. * @method Associate * @param {Object} parameters Parameters for associating records * @param {String} parameters.relationShip Name of relation ship to use for associating * @param {Object} parameters.source Source entity for disassociating * @param {String} [parameters.source.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} parameters.source.entityId ID of entity * @param {String} parameters.source.entityName Logical name of entity, such as &quot;account&quot; * @param {Object} parameters.target Target entity for disassociating * @param {String} [parameters.target.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} parameters.target.entityId ID of entity * @param {String} parameters.target.entityName Logical name of entity, such as &quot;account&quot; * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;String&gt;|String} - Returns Promise&lt;String&gt; if async, just String if sent synchronously. */ WebApiClient.Associate = function(parameters) { var params = parameters || {}; if (!params.relationShip) { throw new Error(&quot;Relationship has to be passed!&quot;); } if (!params.source || !params.target) { throw new Error(&quot;Source and target have to be passed!&quot;); } var targetUrl = GetRecordUrl(params.target); var relationShip = &quot;/&quot; + params.relationShip + &quot;/$ref&quot;; var url = targetUrl + relationShip; var payload = { &quot;@odata.id&quot;: GetRecordUrl(params.source) }; return WebApiClient.SendRequest(&quot;POST&quot;, url, payload, params); }; /** * @description Disassociates given records in CRM. * @method Disassociate * @param {Object} parameters Parameters for disassociating records * @param {String} parameters.relationShip Name of relation ship to use for disassociating * @param {Object} parameters.source Source entity for disassociating * @param {String} [parameters.source.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} parameters.source.entityId ID of entity * @param {String} parameters.source.entityName Logical name of entity, such as &quot;account&quot; * @param {Object} parameters.target Target entity for disassociating * @param {String} [parameters.target.overriddenSetName] Plural name of entity, if not according to plural rules * @param {String} parameters.target.entityId ID of entity * @param {String} parameters.target.entityName Logical name of entity, such as &quot;account&quot; * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;String&gt;|String} - Returns Promise&lt;String&gt; if async, just String if sent synchronously. */ WebApiClient.Disassociate = function(parameters) { var params = parameters || {}; if (!params.relationShip) { throw new Error(&quot;Relationship has to be passed!&quot;); } if (!params.source || !params.target) { throw new Error(&quot;Source and target have to be passed!&quot;); } if (!params.source.entityId) { throw new Error(&quot;Source needs entityId set!&quot;); } var targetUrl = GetRecordUrl(params.target); var relationShip = &quot;/&quot; + params.relationShip + &quot;(&quot; + RemoveIdBrackets(params.source.entityId) + &quot;)/$ref&quot;; var url = targetUrl + relationShip; return WebApiClient.SendRequest(&quot;DELETE&quot;, url, null, params); }; /** * @description Executes the given request in CRM. * @method Execute * @param {Object} request Request to send, must be in prototype chain of WebApiClient.Requests.Request. * @param {Boolean} [request.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [request.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;Object&gt;|Object} - Returns Promise&lt;Object&gt; if async, just Object if sent synchronously. */ WebApiClient.Execute = function(request) { if (!request) { throw new Error(&quot;You need to pass a request!&quot;); } if (!(request instanceof WebApiClient.Requests.Request)) { throw new Error(&quot;Request for execution must be in prototype chain of WebApiClient.Request&quot;); } return WebApiClient.SendRequest(request.method, request.buildUrl(), request.payload, request); }; /** * @description Sends the given batch to CRM. * @method SendBatch * @param {Object} batch Batch to send to CRM * @param {Boolean} [batch.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [batch.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;Object&gt;|Object} - Returns Promise&lt;Object&gt; if async, just Object if sent synchronously. */ WebApiClient.SendBatch = function(batch) { if (!batch) { throw new Error(&quot;You need to pass a batch!&quot;); } if (!(batch instanceof WebApiClient.Batch)) { throw new Error(&quot;Batch for execution must be a WebApiClient.Batch object&quot;); } var url = WebApiClient.GetApiUrl() + &quot;$batch&quot;; batch.headers = batch.headers || []; batch.headers.push({key: &quot;Content-Type&quot;, value: &quot;multipart/mixed;boundary=&quot; + batch.name}); var payload = batch.buildPayload(); return WebApiClient.SendRequest(&quot;POST&quot;, url, payload, batch); }; /** * @description Expands all odata.nextLink (deferred) properties for an array of records. * @method Expand * @param {Object} parameters Configuration for expanding * @param {Array&lt;Object&gt;} parameters.records Array of records to expand * @param {Boolean} [parameters.async] True for sending asynchronous, false for synchronous. Defaults to true. * @param {Array&lt;key:string,value:string&gt;} [parameters.headers] Headers to attach to request * @memberof module:WebApiClient * @return {Promise&lt;Object&gt;|Object} - Returns Promise&lt;Object&gt; if async, just Object if sent synchronously. */ WebApiClient.Expand = function (parameters) { /// &lt;summary&gt;Expands all odata.nextLink / deferred properties for an array of records&lt;/summary&gt; /// &lt;param name=&quot;parameters&quot; type=&quot;Object&quot;&gt;Object that contains 'records' array or object. Optional 'headers'.&lt;/param&gt; /// &lt;returns&gt;Promise for sent request or result if sync.&lt;/returns&gt; var params = parameters || {}; var records = params.records; var requests = []; var asynchronous = GetAsync(parameters); for (var i = 0; i &lt; records.length; i++) { var record = records[i]; for (var attribute in record) { if (!record.hasOwnProperty(attribute)) { continue; } var name = attribute.replace(&quot;@odata.nextLink&quot;, &quot;&quot;); // If nothing changed, this was not a deferred attribute if (!name || name === attribute) { continue; } record[name] = WebApiClient.SendRequest(&quot;GET&quot;, record[attribute], null, params); // Delete @odata.nextLink property delete record[attribute]; } if (asynchronous) { requests.push(Promise.props(record)); } } if (asynchronous) { return Promise.all(requests); } else { return records; } }; module.exports = WebApiClient; } ()); × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Xrm-WebApi-Client Modules WebApiClient Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Xrm-WebApi-Client Modules WebApiClient Dynamics CRM JavaScript Web API Client This is a framework for easing working with the Dynamics CRM WebApi using JavaScript.It uses the awesome BlueBird framework for handling requests asynchronously based on promises.The framework is supposed to be executed on CRM forms or on CRM web ressources, where the CRM context is available.For running from custom web resources, be sure that the GetGlobalContext function is available, as the client will try to retrieve the context on its own. Index Dynamics CRM JavaScript Web API Client Requirements CRM Browser How to obtain it NPM GitHub Release How to build it Operations Synchronous vs Asynchronous Create Return created record in create response Retrieve Retrieve single records Retrieve by ID Retrieve by alternate key Retrieve multiple records Retrieve by query expression Retrieve by FetchXml Auto expand collection-valued navigation properties Update Update by alternate key Return updated record in update response Clear lookup value Delete Delete by alternate key Delete single property Associate Disassociate Execute No parameter request Parametrized request Send Batch How to create batch requests Batch Responses Request failures Configuration Errors Set Names Not yet implemented requests Promises External Access Single Page Application Headers Header Format Default Headers Request Headers Page size API Version Remarks CRM App RequirementsCRMThis framework targets the Dynamics CRM WebApi, therefore CRM 2016 (&gt;= v8.0) is needed. BrowserAlthough using Promises, some legacy browsers are still supported, since bluebird is used as Promise polyfill.Bluebird is automatically included in the bundled release, no additional steps required.For a list of supported browsers, check the bluebird platform support. How to obtain itNPMThis framework is on npm as UMD, thanks to the standalone option of browserify. The package name is xrm-webapi-client, check it out: GitHub ReleaseYou can always download the browserified version of this framework by downloading the release.zip file from the latest release. How to build itYou'll have to install npm on your machine. For bootstrapping, simply run npm install once initially.For every build, you can just call npm run build. You'll find the build output in the Publish directory. OperationsSynchronous vs AsynchronousPer default, all requests are sent asynchronously.This is the suggested way of sending requests, however, sometimes there is the need for using synchronous requests. Be sure to avoid synchronous requests if it is possible and use asynchronous requests instead. For sending requests synchronously, you can either set WebApiClient.Async to false, which will configure the WebApiClient to send all requests synchronously, or pass an async property in your request, like so: var request = { entityName: &quot;account&quot;, entity: {name: &quot;Adventure Works&quot;}, async: false }; try { var response = WebApiClient.Create(request); // Process response } catch (error) { // Handle error }CreateThe client supports creation of records. You have to pass the entity logical name, and a data object: var request = { entityName: &quot;account&quot;, entity: {name: &quot;Adventure Works&quot;} }; WebApiClient.Create(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Return created record in create responseThis feature is available from Dynamics365 v8.2 upwards.For returning the full record that was created from your request, set an appropriate Prefer header as follows: var request = { entityName: &quot;account&quot;, entity: {name: &quot;Adventure Works&quot;}, headers: [{key: &quot;Prefer&quot;, value: &quot;return=representation&quot;}] }; WebApiClient.Create(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });RetrieveThe client supports retrieving of records by Id, by alternate key, fetchXml and query expressions.For retrieving by alternate key, pass an array of objects that each have a property and a value property.You have to pass at least the entity logical name.You can always pass query parameters which will be appended to your retrieve requests. Retrieve single recordsRetrieve by IDvar request = { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot; }; WebApiClient.Retrieve(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Retrieve by alternate keyvar request = { entityName: &quot;contact&quot;, alternateKey: [ { property: &quot;firstname&quot;, value: &quot;Joe&quot; }, { property: &quot;emailaddress1&quot;, value: &quot;abc@example.com&quot;} ] }; WebApiClient.Retrieve(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Retrieve multiple recordsRetrieve of multiple records uses paging. Per default you can set a page size on your requests, however this is limited to 5000 records.If you want to really retrieve all records, set WebApiClient.ReturnAllPages to true, as it is by default false, like this: WebApiClient.ReturnAllPages = true;By setting this to true, each retrieve multiple request will check for an @odata.nextLink property inside the response, call the next page and concatenate the results, until all records have been retrieved. You can also pass this option per-request, like this: var request = { entityName: &quot;account&quot;, queryParams: &quot;?$select=name,revenue,&amp;$orderby=revenue asc,name desc&amp;$filter=revenue ne null&quot;, returnAllPages: true };Retrieve by query expressionvar request = { entityName: &quot;account&quot;, queryParams: &quot;?$select=name,revenue,&amp;$orderby=revenue asc,name desc&amp;$filter=revenue ne null&quot; }; WebApiClient.Retrieve(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Retrieve by FetchXmlFetchXml requests have some special behaviour implemented. Short fetchXml will be sent as GET request using a fetchXml URL query parameter.There is however an URL length limit of 2048 chars, so large fetchXml requests would fail, since they exceed this limit.Since release v3.1.0, the request will automatically be sent as POST batch request, so that large fetchXml can be executed as well.You don't have to do anything for this to happen, the URL length is checked automatically before sending the request. var request = { entityName: &quot;account&quot;, fetchXml: &quot;&lt;fetch mapping='logical'&gt;&quot; + &quot;&lt;entity name='account'&gt;&quot; + &quot;&lt;attribute name='accountid'/&gt;&quot; + &quot;&lt;attribute name='name'/&gt;&quot; + &quot;&lt;/entity&gt;&quot; + &quot;&lt;/fetch&gt;&quot; }; WebApiClient.Retrieve(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Auto expand collection-valued navigation propertiesWhen retrieving collection-valued navigation properties, the expand is being deferred, i.e. you don't retrieve immediate results, but a property ending in &quot;@odata.nextLink&quot; that contains an URL to the results for this expand. You can read more about this here.For easing to retrieve these, we can use the WebApiClient.Expand function. It takes an array of records and expands all properties, that end in &quot;@odata.nextLink&quot;.You can additionally pass headers to the request, that will be appended to each retrieve request for properties. WebApiClient.Retrieve({ entityName: &quot;account&quot;, queryParams: &quot;?$expand=contact_customer_accounts&quot; }) .then(function(response){ return WebApiClient.Expand({ records: response.value }); }) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });UpdateUpdate requests are supported. You have to pass the entity logical name, the ID of the record to update and an update object: var request = { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot;, entity: { name: &quot;Contoso&quot; } }; WebApiClient.Update(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Update by alternate keyvar request = { entityName: &quot;contact&quot;, alternateKey: [ { property: &quot;firstname&quot;, value: &quot;Joe&quot; }, { property: &quot;emailaddress1&quot;, value: &quot;abc@example.com&quot;} ], entity: { lastname: &quot;Doe&quot; } }; WebApiClient.Update(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Return updated record in update responseThis feature is available from Dynamics365 v8.2 upwards.For returning the full record after applying the updates from your request, set an appropriate Prefer header as follows: var request = { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot;, entity: { name: &quot;Contoso&quot; }, headers: [{key: &quot;Prefer&quot;, value: &quot;return=representation&quot;}] }; WebApiClient.Update(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Clear Lookup valueIf you're trying to clear a lookup value using an update with a null value, it might very well be, that it simply does nothing, or fails with an error such as Property _pub_field_value cannot be updated to null. The reference property can only be deleted.In this case, you can not use an update request for clearing the lookup. Take a look at the delete single property section. DeleteDelete requests are supported. You have to pass the entity logical name, and ID of the record to delete: var request = { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot; }; WebApiClient.Delete(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Delete by alternate keyvar request = { entityName: &quot;contact&quot;, alternateKey: [ { property: &quot;firstname&quot;, value: &quot;Joe&quot; }, { property: &quot;emailaddress1&quot;, value: &quot;abc@example.com&quot;} ] }; WebApiClient.Delete(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Delete single propertyYou can delete single properties by passing the field to clear as queryParams with a preceding slash, like &quot;/telephone1&quot;.If it is a lookup, you'll have to prepend &quot;/$ref&quot;, such as &quot;/primarycontactid/$ref&quot;. var request = { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot;, queryParams: &quot;/primarycontactid/$ref&quot; }; WebApiClient.Delete(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });AssociateAssociate requests are supported. You have to pass the relationship name, a source and a target entity.This example associates an opportuntiy to an account: var request = { relationShip: &quot;opportunity_customer_accounts&quot;, source: { entityName: &quot;opportunity&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot; }, target: { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000002&quot; } }; WebApiClient.Associate(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });DisassociateDisassociate requests are supported. You have to pass the relationship name, a source and a target entity.This example disassociates an opportuntiy from an account: var request = { relationShip: &quot;opportunity_customer_accounts&quot;, source: { entityName: &quot;opportunity&quot;, entityId: &quot;00000000-0000-0000-0000-000000000001&quot; }, target: { entityName: &quot;account&quot;, entityId: &quot;00000000-0000-0000-0000-000000000002&quot; } }; WebApiClient.Disassociate(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });ExecuteThere is support for executing actions / functions without having to use SendRequest.The WebApiClient has a function WebApiClient.Execute, which takes a request as parameter.Requests are objects that base on the WebApiClient.Requests.Request base request.When wanting to send an already implemented request using Execute, you can either use the blank request (such as the WhoAmIRequest, that does not need any parameters), or in case it needs parameters, extend an existing request. Missing or custom action requests can be implemented as described here. Check the wiki for a list of requests that are implemented in the current release and examples on how to send them! No parameter requestThe WhoAmI request does not need any parameters, therefore we can just pass the blank request: var request = WebApiClient.Requests.WhoAmIRequest; WebApiClient.Execute(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Parametrized requestMost requests need further parameters for being sent.When needing to send those requests, start with the blank request and call the function &quot;with&quot; on it, passing the needed parameters as object to it. Your passed-in parameters override possibly existing parameters with the same name. The following parameters are supported: method - HTTP method for request (Required, but defined by request) name - Name of the request as used for the URL (Required, but defined by request) bound - Pass true if request is bound to a record, false if not. Has consequences for automatic URL building. By default false and defined by request. entityName - Name of the request's target entity. Defined by request if always the same. entityId - ID of the request's target record payload - Object that is sent as payload for the request headers - Headers that should be set on the request urlParams - Any parameters that have to be embedded in the request URL, as described here. Pass an object with parameter names as keys and the corresponding values. Sample request for AddToQueue: var request = WebApiClient.Requests.AddToQueueRequest .with({ entityId: &quot;56ae8258-4878-e511-80d4-00155d2a68d1&quot;, payload: { Target: { activityid: &quot;59ae8258-4878-e511-80d4-00155d2a68d1&quot;, &quot;@odata.type&quot;: &quot;Microsoft.Dynamics.CRM.letter&quot; } } }); WebApiClient.Execute(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Send BatchThere is support for sending multiple requests as a batch. Batch requests can contain retrieve requests and change sets. Change sets can contain requests themselves, however they must not contain other change sets. Requests directly attached to batch requests have to be GET requests, they must not be added to change sets, since those have to contain requests, that change data.Batch requests provide transactional functionality, so all operations contained in one change set will roll back, if any of them fails.You can read more about batch requests in general here.There is also a useful OData Reference covering this topic (albeit v3.0). How to create batch requestsFor creating requests for usage inside batches, you can either create a WebApiClient.BatchRequest object using its constructor, or easier, call one of the WebApiClient functions and pass asBatch: true as parameter. All functions, such as CRUD, Execute and so on support this parameter. The only exception to it is the Expand function. Below is an example for creating two tasks attached to an account in one change set, while returning the records created.Afterwards, the account they were attached to is returned: WebApiClient.Create({entityName: &quot;account&quot;, entity: { name: &quot;Test&quot; }}) .then(function (account) { var accountId = account.substring(account.indexOf(&quot;(&quot;)).replace(&quot;(&quot;, &quot;&quot;).replace(&quot;)&quot;,&quot;&quot;); var batch = new WebApiClient.Batch({ changeSets: [ new WebApiClient.ChangeSet({ requests: [ WebApiClient.Create({ entityName: &quot;task&quot;, entity: { subject: &quot;Task 1 in batch&quot;, &quot;regardingobjectid_account_task@odata.bind&quot;: &quot;/accounts(&quot; + accountId + &quot;)&quot; }, headers: [{key: &quot;Prefer&quot;, value:&quot;return=representation&quot;}], asBatch: true }), WebApiClient.Create({ entityName: &quot;task&quot;, entity: { subject: &quot;Task 2 in batch&quot;, &quot;regardingobjectid_account_task@odata.bind&quot;: &quot;/accounts(&quot; + accountId + &quot;)&quot; }, headers: [{key: &quot;Prefer&quot;, value:&quot;return=representation&quot;}], asBatch: true }) ] })], requests: [ WebApiClient.Retrieve({ entityName: &quot;account&quot;, entityId: accountId, asBatch: true }) ] }); return WebApiClient.SendBatch(batch); }) .then(function(result) { if(result.isFaulted) { console.log(result.errors); } // Logs BatchResponse with name, batchResponses array and changeSetResponses array console.log(result); }) .catch(function(error) { // Handle network error or similar });Note: Above code is only an example, you could also create your batch and change sets separately and add the change sets to batch.changeSets, requests inside the change sets to changeSet.requests and plain batch requests to batch.requests, which are all arrays. Batch ResponsesCalls to WebApiClient.SendBatch will return a BatchResponse.A batch response consist of an array batchResponses, that contains all responses for GET requests, that were directly attached to the batch and an array changeSetResponses, that contains one change set response for each change set that was sent.Each change set response contains its own responses array, with responses for each request inside the changset. At the top level, each batch response also has a name, an isFaulted property that evaluates to true, if any of the requests failed and an errors array that contains all responses for failed requests. The lowest level responses all contain a headers object, so you can access headers easier (e.g. headers[&quot;OData-EntityId&quot;]), a payload object, a status (such as &quot;200&quot;) and a contentId, if the requests inside the change set had one set. Scheme of a batch response: batchResponses (array) Response (WebApiClient.Response) contentId (string) headers (array of string * string) payload (object) status (string) ... changeSetResponses (array) changeSetResponse (object) name (string) responses (array) Response (WebApiClient.Response) contentId (string) headers (array of string * string) payload (object) status (string) ... errors (array of WebApiClient.Response) isFaulted (bool) name (string) Request failuresIf a request inside the batch requests or a change set fails, the batch response property isFaulted will have the value true.You can get a collection of all errors using the response property errors. This is all inside the then handler, remember that you should still configure a catch handler, as this will be needed if a requests fails due to network errors or similar. ConfigurationWhen having to set multiple configuration settings for the WebApiClient, you can use the Configure function, which gets an object passed with keys and values, that get projected onto the WebApiClient: WebApiClient.Configure({ ApiVersion: &quot;8.2&quot;, ReturnAllPages: true, PrettifyErrors: false });ErrorsIf errors occur during processing of requests, the WebAPI client by default throws an error with the text that follows this format: xhr.statusText: xhr.response.message, i.e. &quot;Internal Server Error: The function parameter 'EntityMoniker' cannot be found.Parameter name: parameterName&quot;. For returning the whole stringified JSON response including a custom xhrStatusText property, set WebApiClient.PrettifyErrors = false;Set NamesSet names are automatically generated according to WebApi rules and based on the entityName parameter in your request.However there are some set names, that are not generated according to naming rules, for example ContactLeads becomes contactleadscollection. For handling those corner cases, each request allows to pass an overriddenSetName instead of the entity name, so that you can directly pass those set names that break naming rules. This should happen very rarely.Example of passing overriddenSetName: var request = { overriddenSetName: &quot;contactleadscollection&quot;, entity: {name: &quot;Contoso&quot;} }; WebApiClient.Create(request) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });Not yet implemented requestsIf you need to use requests, that are not yet implemented (such as custom actions), you can create an executor for the missing request and append it to the WebApiClient.Requests object (if you want to reuse it). Be sure to create your missing request by calling Object.create on the base request object.This might look something like this: WebApiClient.Requests.AddToQueueRequest = WebApiClient.Requests.Request.prototype.with({ method: &quot;POST&quot;, name: &quot;AddToQueue&quot;, bound: true, entityName: &quot;queue&quot; });For further explanations regarding these requests, please check here.All requests should be implemented basically by now, in case of any errors in the implementations, you can override any property using the with function as described here. Alternatively, you can use the WebApiClient.SendRequest function.In combination with WebApiClient.GetApiUrl and WebApiClient.GetSetName you can easily build up your request url, set your HTTP method and attach additional payload or headers. An example of a custom implementation of the WinOpportunity request: var url = WebApiClient.GetApiUrl() + &quot;WinOpportunity&quot;; var opportunityId = &quot;00000000-0000-0000-0000-000000000001&quot;; var payload = { &quot;Status&quot;: 3, &quot;OpportunityClose&quot;: { &quot;subject&quot;: &quot;Won Opportunity&quot;, &quot;opportunityid@odata.bind&quot;: &quot;/&quot; + WebApiClient.GetSetName(&quot;opportunity&quot;) + &quot;(&quot; + opportunityId + &quot;)&quot; } }; WebApiClient.SendRequest(&quot;POST&quot;, url, payload) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });PromisesThis client uses bluebird internally for handling promises in a cross-browser compliant way.Therefore the promises returned by all asynchronous requests are also bluebird promises.Bluebird itself is not exported globally anymore as of v3.0.0, but can be accessed by using WebApiClient.Promise.This decision was made for not causing issues with other scripts. Using promises you can do something like this, too: var requests = []; for (var i = 0; i &lt; 5; i++) { var request = { entityName: &quot;account&quot;, entity: {name: &quot;Adventure Works Nr. &quot; + i} }; requests.push(WebApiClient.Create(request)); } WebApiClient.Promise.all(requests) .then(function(response){ // Process response }) .catch(function(error) { // Handle error });External AccessExternal access to CRM, that is accessing CRM without being on a CRM form or having a ClientGlobalContext.aspx is supported.As OAuth is required for authenticating, only CRM online and CRM On-Premises with IFD and Azure AD are supported. You'll have to register the WebApiClient as App in Azure AD, which is described in MSDN. Single Page ApplicationThere is support for using the client inside external single page applications. There is a minimal working example in the sample folder. HeadersThere is a defined set of default headers, which are sent on each request, as well as per-request headers.Per-request headers override possibly existing default headers with the same key value. Header FormatHeaders are represented as objects containing a key and a value property: var header = { key: &quot;headerKey&quot;, value: &quot;headerValue&quot; };Default HeadersBy default there is a defined set of default headers, that will be sent with each request.The default headers can be retrieved using the WebApiClient.GetDefaultHeaders function.You can however add own default headers by using the WebApiClient.AppendToDefaultHeaders function, which takes as much headers as dynamic arguments as you like. Example: var header = {key: &quot;newHeader&quot;, value: &quot;newValue&quot;}; WebApiClient.AppendToDefaultHeaders (header);Request HeadersYou can also attach headers per request, all request parameters have a headers property, that can be used for passing per-request headers. This could look something like this: // Parameters for create request var request = { entityName: &quot;account&quot;, entity: {name: &quot;Adventure Works&quot;}, headers: [ { key: &quot;headerKey&quot;, value: &quot;headerValue&quot; }] };Page sizeIf you want to set a max page size for your request (supported are up to 5000 records per page), you can pass the following header: headers: [ { key: &quot;Prefer&quot;, value: &quot;odata.maxpagesize=5000&quot; }]API VersionThe default API version is 8.0.You can however change it to 8.1 if needed by using WebApiClient.ApiVersion = &quot;8.1&quot;;RemarksCRM AppFor using WebApiClient with the CRM App, you'll have to use the normal (= not uglified) version.When using uglified JS in the CRM App, you might receive invalid character errors. This is not only valid for the WebApiClient, but also for some other uglified code. × Search results Close "},"module-WebApiClient.html":{"id":"module-WebApiClient.html","title":"Module: WebApiClient","body":" Xrm-WebApi-Client Modules WebApiClient Module: WebApiClient This is the core functionality of Xrm-WebApi-ClientNo instantiation needed, it's a singleton. Source: WebApiClient.Core.js, line 29 Members &lt;static&gt; WebApiClient.ApiVersion The API version that will be used when sending requests. Default is &quot;8.0&quot; Source: WebApiClient.Core.js, line 45 &lt;static&gt; WebApiClient.Async Set to false for sending all requests synchronously. True by default. Source: WebApiClient.Core.js, line 66 &lt;static&gt; WebApiClient.ClientUrl Connection to use when being used in a single page app. Source: WebApiClient.Core.js, line 73 &lt;static&gt; WebApiClient.PrettifyErrors Set to true for retrieving formatted error in style 'xhr.statusText: xhr.error.Message'. If set to false, error json will be returned. Source: WebApiClient.Core.js, line 59 &lt;static&gt; WebApiClient.ReturnAllPages Checks for more pages when retrieving results. If set to true, all pages will be retrieved, if set to false, only the first page will be retrieved. Source: WebApiClient.Core.js, line 52 &lt;static&gt; WebApiClient.Token Token to use for authenticating when being used in a single page app. Source: WebApiClient.Core.js, line 80 Methods &lt;static&gt; AppendToDefaultHeaders(var_args) Function for building the set name of a given entity name. Parameters: Name Type Argument Description var_args Object &lt;repeatable&gt; Headers as variable arguments Source: WebApiClient.Core.js, line 191 Returns: Type void &lt;static&gt; Associate(parameters) Associates given records in CRM. Parameters: Name Type Description parameters Object Parameters for associating records Properties Name Type Argument Description relationShip String Name of relation ship to use for associating source Object Source entity for disassociating Properties Name Type Argument Description overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String ID of entity entityName String Logical name of entity, such as &quot;account&quot; target Object Target entity for disassociating Properties Name Type Argument Description overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String ID of entity entityName String Logical name of entity, such as &quot;account&quot; async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 785 Returns: Returns Promise if async, just String if sent synchronously. Type Promise.&lt;String&gt; | String &lt;static&gt; Configure(configuration) Applies configuration to WebApiClient. Parameters: Name Type Description configuration Object Object with keys named after WebApiClient Members, such as &quot;Token&quot;s Source: WebApiClient.Core.js, line 644 Returns: Type void &lt;static&gt; Create(parameters) Creates a given record in CRM. Parameters: Name Type Description parameters Object Parameters for creating record Properties Name Type Argument Description entityName String Entity name of record that should be created overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entity Object Object containing record data async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 671 Returns: Returns Promise if return=representation header is set, otherwise Promise. Just Object or String if sent synchronously. Type Promise.&lt;String&gt; | Promise.&lt;object&gt; | String | Object &lt;static&gt; Delete(parameters) Deletes a given record in CRM. Parameters: Name Type Description parameters Object Parameters for deleting record Properties Name Type Argument Description entityName String Entity name of records that should be deleted overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String &lt;optional&gt; ID of entity to delete alternateKey Array.&lt;property:string, value:string&gt; &lt;optional&gt; Alternate key array for deleting record async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 761 Returns: Returns Promise if async, just String if sent synchronously. Type Promise.&lt;String&gt; | String &lt;static&gt; Disassociate(parameters) Disassociates given records in CRM. Parameters: Name Type Description parameters Object Parameters for disassociating records Properties Name Type Argument Description relationShip String Name of relation ship to use for disassociating source Object Source entity for disassociating Properties Name Type Argument Description overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String ID of entity entityName String Logical name of entity, such as &quot;account&quot; target Object Target entity for disassociating Properties Name Type Argument Description overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String ID of entity entityName String Logical name of entity, such as &quot;account&quot; async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 824 Returns: Returns Promise if async, just String if sent synchronously. Type Promise.&lt;String&gt; | String &lt;static&gt; Execute(request) Executes the given request in CRM. Parameters: Name Type Description request Object Request to send, must be in prototype chain of WebApiClient.Requests.Request. Properties Name Type Argument Description async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 865 Returns: Returns Promise if async, just Object if sent synchronously. Type Promise.&lt;Object&gt; | Object &lt;static&gt; Expand(parameters) Expands all odata.nextLink (deferred) properties for an array of records. Parameters: Name Type Description parameters Object Configuration for expanding Properties Name Type Argument Description records Array.&lt;Object&gt; Array of records to expand async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 914 Returns: Returns Promise if async, just Object if sent synchronously. Type Promise.&lt;Object&gt; | Object &lt;static&gt; GetApiUrl() Gets the current base API url that is used. Source: WebApiClient.Core.js, line 661 Returns: Type String &lt;static&gt; GetDefaultHeaders() Returns array of default headers. Source: WebApiClient.Core.js, line 175 Returns: Type Array.&lt;{key: String, value:String}&gt; &lt;static&gt; GetSetName(entityName [, overriddenSetName]) Builds the set name of a given entity name. Parameters: Name Type Argument Description entityName String Logical name of the entity, such as &quot;account&quot; overriddenSetName String &lt;optional&gt; Override set name if it can't be infered from plural rules Source: WebApiClient.Core.js, line 140 Returns: Type String &lt;static&gt; Retrieve(parameters) Retrieves records from CRM Parameters: Name Type Description parameters Object Parameters for retrieving records Properties Name Type Argument Description entityName String Entity name of records that should be retrieved overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules queryParams String &lt;optional&gt; Query Parameters to append to URL, such as ?$select=* fetchXml String &lt;optional&gt; Fetch XML query entityId String &lt;optional&gt; ID of entity to retrieve, will return single record alternateKey Array.&lt;property:string, value:string&gt; &lt;optional&gt; Alternate key array for retrieving single record async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 695 Returns: Returns Promise if asyncj, just Object if sent synchronously. Type Promise.&lt;object&gt; | Object &lt;static&gt; SendBatch(batch) Sends the given batch to CRM. Parameters: Name Type Description batch Object Batch to send to CRM Properties Name Type Argument Description async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 886 Returns: Returns Promise if async, just Object if sent synchronously. Type Promise.&lt;Object&gt; | Object &lt;static&gt; SendRequest(method, url [, payload] [, parameters]) Sends request using given parameters. Parameters: Name Type Argument Description method String Method type of request to send, such as &quot;GET&quot; url String Target URL for request. payload Object &lt;optional&gt; Payload for request. parameters Object &lt;optional&gt; Parameters for sending the request Properties Name Type Argument Description async Boolean &lt;optional&gt; True for sending async, false for sync. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers for appending to request Source: WebApiClient.Core.js, line 599 Returns: Type Promise.&lt;Object&gt; | Object &lt;static&gt; Update(parameters) Updates a given record in CRM. Parameters: Name Type Description parameters Object Parameters for updating record Properties Name Type Argument Description entityName String Entity name of records that should be updated overriddenSetName String &lt;optional&gt; Plural name of entity, if not according to plural rules entityId String &lt;optional&gt; ID of entity to update alternateKey Array.&lt;property:string, value:string&gt; &lt;optional&gt; Alternate key array for updating record async Boolean &lt;optional&gt; True for sending asynchronous, false for synchronous. Defaults to true. headers Array.&lt;key:string, value:string&gt; &lt;optional&gt; Headers to attach to request Source: WebApiClient.Core.js, line 736 Returns: Returns Promise if return=representation header is set, otherwise Promise. Just Object or String if sent synchronously. Type Promise.&lt;String&gt; | Promise.&lt;object&gt; | String | Object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
